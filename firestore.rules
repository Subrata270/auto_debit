
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    // This function checks for existence before trying to get data, preventing errors on create.
    function getUserData() {
      return exists(/databases/$(database)/documents/users/$(request.auth.uid))
         ? get(/databases/$(database)/documents/users/$(request.auth.uid)).data
         : null;
    }

    function isRole(role) {
      // Use this only when you are sure the user document exists.
      let userData = getUserData();
      return userData != null && userData.role == role;
    }

    function isSubRole(subrole) {
      let userData = getUserData();
      return userData != null && userData.subrole == subrole;
    }
    
    function isDepartment(department) {
      let userData = getUserData();
      return userData != null && userData.department == department;
    }

    // Users collection
    // This rule MUST come first to ensure new users can create their own profile.
    match /users/{userId} {
      // A user can create their own document, and only their own.
      // This rule is intentionally simple to avoid issues during initial registration.
      allow create: if request.auth != null && request.auth.uid == userId;

      // After creation, a user can only read or update their own document.
      allow read, update: if isOwner(userId);
      
      // Admins can list or delete any user.
      allow list, delete: if isRole('admin');
    }

    // Subscriptions collection
    match /subscriptions/{subscriptionId} {
      // An employee can create a request.
      // We check the incoming resource data, NOT a get() call.
      allow create: if isSignedIn() && request.resource.data.requestedBy == request.auth.uid;

      // An employee can read their own dept subscriptions, HOD their dept, and finance/admin can read all.
      // The rules are now based on the incoming resource data, not a separate `get()` call.
      allow read: if (isOwner(resource.data.requestedBy) || 
                      (isRole('hod') && isDepartment(resource.data.department)) ||
                      isRole('finance') || isRole('admin'));
                      
      // Only finance or admin can list all subscriptions.
      allow list: if isRole('finance') || isRole('admin');

      // Update rules remain complex but rely on the same principle.
      allow update: if (isRole('hod') && isDepartment(resource.data.department) && request.resource.data.status in ['Approved by HOD', 'Declined by HOD']) ||
                      (isRole('finance') && isSubRole('apa') && request.resource.data.status in ['Approved by APA', 'Declined by APA']) ||
                      (isRole('finance') && isSubRole('am') && request.resource.data.status == 'Active');
                      
      // Only admin can delete.
      allow delete: if isRole('admin');
    }

    // Notifications collection
    match /notifications/{notificationId} {
      // Allow system processes (or any signed-in user) to create notifications.
      allow create: if isSignedIn();
      
      // Users can only manage their own notifications.
      allow read, update, delete: if isOwner(resource.data.userId);
      
      // Disallow listing all notifications. Users should query their own.
      allow list: if false; 
    }
  }
}
